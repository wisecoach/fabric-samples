## Fabric概念介绍和梳理

[toc]

### 一、概要



Fabric有大量的概念，我会以一定的逻辑顺序按照一定的分类大致介绍这些概念：

1. 节点：

   1. 逻辑：我们刚部署完fabric网络，对节点相对比较熟悉，它们也是各种概念的载体，比较适合作为出发点
   2. 内容：peer、orderer、cli等

2. 数据：

   1. 逻辑：区块链核心就是对数据的存储，我们必须了解各个节点要存储哪些数据
   2. 内容：channel通道、ledger账本、世界状态world state、区块链blockchain、区块block、交易transaction等

3. 交易流程和节点提供的服务

   1. 逻辑：区块链上所有数据的修改都是通过transaction完成的，我们有必要去大致了解一下交易的流程以及完成这个流程各个节点完成的事以及提供的服务
   2. 内容：交易流程、排序服务、背书服务、Deliver服务、AtomciBroadcast服务、Gossip服务 

4. 排序服务和共识

   1. 逻辑：是排序服务的扩展，这里涉及区块链最重要的机制共识
   2. 内容：各个版本可选择的共识机制

5. 背书服务和链码

   1. 逻辑：背书服务的核心就是链码的执行，这块主要介绍链码的概念
   2. 内容：链码、背书策略

6. 身份和权限

   1. 逻辑：之前忽略了身份和权限的概念，这时候适合提及
   2. 内容：组织、身份、FabricCA、MSP、策略、配置

   

   

### 二、节点

![image-20230817150757235](/home/wisecoach/.config/Typora/typora-user-images/image-20230817150757235.png)

1. 节点：任意类型的节点都需要绑定一个身份（证书），属于一个组织，他们之间采用P2P的方式通信，即既可以作为客户端也可以作为服务端
2. 普通peer节点：https://hyperledger-fabric.readthedocs.io/en/release-2.5/peers/peers.html
   1. 存储账本的节点，Fabric是一个允许多账本的网络，每个peer节点允许维护多个账本
3. Endorse节点：
   1. 安装有交易所对应链码的peer节点就是对应交易的背书节点，只有这些节点有能力执行交易，其他peer节点只是导入背书产生的读写集
4. LeaderPeer节点：
   1. 一个组织内部向Orderer节点拉取对应通道的区块，并分发给组织内其他peer节点
   2. Leader节点通过Gossip协议在组织内动态选举
5. AnchorPeer节点：
   1. peer节点通常只维护组织内peer的发现服务，对于其他组织的节点仅维护anchor节点，通过anchor节点与其他组织交互
   2. anchor节点在channel的配置区块中设置，包括endpoint(ip + port)信息
   3. 最初peer节点不知道组织内其他peer节点，仅通过配置区块知道anchor节点，再通过anchor认识组织内其他peer节点，作用很重要
6. Orderer节点：https://hyperledger-fabric.readthedocs.io/en/release-2.5/orderer/ordering_service.html
   1. Fabric将处理交易和打包交易出块进行了拆分，peer节点处理交易，orderer节点对交易排序出块
   2. 一般区块链共识的范围是所有节点，fabric的共识是订阅了对应通道的所有orderer节点
7. 客户端节点：
   1. 访问fabric网络的节点，可以是命令行调用，也可以是java、go、javascript编写的客户端



### 三、数据

1. channel通道：https://hyperledger-fabric.readthedocs.io/en/release-2.5/channels.html

   1. 它其实不算数据相关的概念，它代表的是整个Fabric网络的一个子集，这个子集内的成员会维护一个账本ledger
   2. 子集的范围由channel的配置决定，它配置的方式为允许哪些组织参与该channel

2. ledger账本：https://hyperledger-fabric.readthedocs.io/en/release-2.5/ledger/ledger.html

   1. 一个通道对应一个账本，账本包括区块链以及区块所累积得到的世界状态

3. 世界状态：

   1. 简单来说就是一个key-value的Map，它的实现一般就是一个NoSql
   2. 它的状态会由且仅由交易完成，一般称之为基于交易的状态复制机，只要输入的交易一样，最终的得到的结果也一样

4. 区块链：

   1. 就是由区块构成的链，由区块中的prevHash来连接上一个区块
   2. 在Fabric中的实现就是文件，以一个个blockFile构成

5. 区块：

   1. 就是很正常的一个区块

      1. block data中存储了多个交易
      2. blockheader中存储了datahash,它是blockdata的hash值，prevhash存储了上一个区块的datahash,用于连接成区块链

      ![ledger.blockchain](https://hyperledger-fabric.readthedocs.io/en/release-2.5/_images/ledger.diagram.2.png)

6. 交易

   1. 一般来说，交易就是对一次对链码的调用，里面会包含

      1. 调用的链码名(chaincodeName)、交易名（contractName:transactionName，链码提供的一个接口），代表调用那个链码和链码中哪个接口
      2. 链码调用的入参、返回值
      3. 链码背书的读写集，链码的本质就是对世界状态的CRUD,对应的也会产生的key-value读写集

   2. 区块中存储的可能是配置或是交易，我们可以把配置视为一种特殊的交易，不多做考虑，我们仅考虑调用链码的交易;

      

### 四、交易流程和节点提供的服务

交易流程：https://hyperledger-fabric.readthedocs.io/en/release-2.5/txflow.html?highlight=transaction

1. 客户端初始化一个Transaction![_images/step1.png](/mnt/E/note/blockchain/fabric学习笔记.assets/step1-16424418519872.png)

   客户端A调用SDK，产生transaction proposal，它包含调用链码所需的参数，将proposal发送给该链码的背书策略所需要的Endorser节点。

   这块目前，我还没有过多涉及。

2. 背书节点验证proposal并模拟事务，返回背书结果

   ![_images/step2.png](/mnt/E/note/blockchain/fabric学习笔记.assets/step2.png)

   1. 收到proposal的背书节点检查
      1. proposal是否合法
      2. 是否已经被提交
      3. 检查proposal是否被调用者用户Client A正确签名
      4. 确保Client A 有权利去执行该操作
   2. 把proposal提供参数作为chaincode的输入，根据当前的world state进行执行，生成事务结果，包括response value、read set、write set。目前不会对ledger进行修改
   3. 以上的事务结果在被背书节点签名后，作为proposal response返回给Client A

3. 检测proposal response![_images/step3.png](/mnt/E/note/blockchain/fabric学习笔记.assets/step3.png)

   1. Client A 验证收到的proposal response是否符合签名，并且比较response是否相同
   2. 如果是query response，则不必提交给orderer节点
   3. 把其中一致的proposal response写入到transaction中，判断是否满足背书政策，如果满足再提交给orderer节点，当然之后会有其他措施保证其符合

4. 客户端合并背书到事务中，并且将事务发送给排序服务，完成排序上链![_images/step4.png](/mnt/E/note/blockchain/fabric学习笔记.assets/step4.png)

   交易中包含读写集、背书节点的签名和channel ID，排序节点无需完成最终检查任务，只需要把事务按时间和channel进行排序，并且创建事务block

5. 区块分发，事务被验证和提交![_images/step5.png](/mnt/E/note/blockchain/fabric学习笔记.assets/step5.png)

   1. 排序节点把封装有transaction的block分发给所有加入对应channel的peers
   2. 每个peer会去检查区块中的事务
      1. 事务是否符合背书策略
      2. 根据事务中的read set，判断world state是否在期间有被修改过
   3. 根据以上判断，给block中的每个transaction打上是否有效的标签

6. 修改账本![_images/step6.png](/mnt/E/note/blockchain/fabric学习笔记.assets/step6.png)

   1. peer节点将区块添加到区块链上
   2. 将所有有效的事务的写集提交给world state 数据库
   3. 发送一个event给Client A，通知事务是否有效

   ![_images/flow-4.png](/mnt/E/note/blockchain/fabric学习笔记.assets/flow-4.png)

Fabric的交易流是区块链中比较特殊的一种交易流，一般交易流可以分为：

1. 先定序后执行：先通过共识将所有交易排好序出块，块到节点手上再验证并执行
2. 先执行后定序：先执行出结果，将结果连同交易发送给出块者，出块者排好序后发送节点，节点拿到块后仅验证 





![image-20230817174124935](/home/wisecoach/.config/Typora/typora-user-images/image-20230817174124935.png)

注意：这里的提到的服务类似我们用的前后端接口文档，是一个节点对外暴露的接口

1. 背书服务
   1. 由endorser节点提供，用于对client节点提供的交易proposal进行背书，执行交易对应的链码，得到对应的读写集
2. Broadcast服务
   1. 由orderer节点提供，主要由client节点（v2.3后由peer节点）调用，将满足背书策略的proposal发送给Orderer节点，等待排序打包出块
3. Cluster服务（排序服务）：https://hyperledger-fabric.readthedocs.io/en/release-2.5/orderer/ordering_service.html
   1. 由orderer节点提供，orderer节点之间互相调用，用于实现不同的共识算法
4. Deliver服务
   1. 由orderer节点提供，由peer节点调用，用于拉取对应channel的区块
   2. peer节点也会提供，由client节点调用，也用于拉取对应channel的区块
5. Gossip服务：https://hyperledger-fabric.readthedocs.io/en/release-2.5/gossip.html
   1. 由peer节点提供，peer节点之间互相调用，核心是用于保证peer之间的最终一致性
6. Discovery服务
   1. 由peer节点提供，client和peer节点都可以调用，主要用于查询其他peer维护的配置信息、链码信息、存活peer信息等



### 五、排序服务和共识
